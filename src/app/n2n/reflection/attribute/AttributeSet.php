<?php

namespace n2n\reflection\attribute;

use n2n\reflection\attribute\legacy\LegacyConverter;
use n2n\reflection\ReflectionContext;
use n2n\util\ex\UnsupportedOperationException;
use n2n\util\type\ArgUtils;
use ReflectionClass;

class AttributeSet {
    private const TYPE_CLASS = 'cl';
    private const TYPE_CONSTANT = 'co';
    private const TYPE_PROPERTY = 'p';
    private const TYPE_METHOD = 'm';

	/**
	 * The loaded Attributes are stored here
     * @var Attribute[][][]
	 */
	private array $attributes = array(self::TYPE_CLASS => [], self::TYPE_CONSTANT => [], self::TYPE_PROPERTY => [],
            self::TYPE_METHOD => []);

	/**
	 * Store keys generated by {@link AttributeSet::loadedKey()} for tracking loaded items.
	 * @var string[]
	 */
	private array $loadedKeys = array();

	private LegacyConverter $legacyConverter;

	/**
	 * @param ReflectionClass $class
	 */
	public function __construct(private ReflectionClass $class) {
		$this->legacyConverter = new LegacyConverter(ReflectionContext::getAnnotationSet($this->class));
	}

	/**
	 * @return ClassAttribute[]
	 */
	public function getClassAttributes(): array {
		if (!$this->isLoaded(self::TYPE_CLASS)) {
			$this->loadType(self::TYPE_CLASS);
		}

		return $this->unGroup($this->attributes[self::TYPE_CLASS]);
	}

	/**
	 * @param string $attributeName
	 * @return boolean
	 */
	public function hasClassAttribute(string $attributeName): bool {
		return null !== $this->getClassAttribute($attributeName);
	}

	/**
	 * @param string $attributeName
	 * @return ClassAttribute|null
	 */
	public function getClassAttribute(string $attributeName): ClassAttribute|null {
        return $this->loadAttributeFromReflector(self::TYPE_CLASS, $attributeName, $this->class);
	}

	/**
	 * @return PropertyAttribute[]
	 */
	public function getPropertyAttributes(): array {
		if (!$this->isLoaded(self::TYPE_PROPERTY)) {
			$this->loadType(self::TYPE_PROPERTY);
		}

		return $this->unGroup($this->attributes[self::TYPE_PROPERTY]);
	}

	/**
	 * @param string $attributeName
	 * @return PropertyAttribute[]
	 */
	public function getPropertyAttributesByName(string $attributeName): array {
		return $this->loadAttributes(self::TYPE_PROPERTY, $attributeName);
	}

	/**
	 * @param string $propertyName
	 * @param string $attributeName
     * @throws \ReflectionException
	 * @return boolean
	 */
	public function hasPropertyAttribute(string $propertyName, string $attributeName): bool {
		return null !== $this->getPropertyAttribute($propertyName, $attributeName);
	}

	/**
	 * @param string $propertyName
	 * @param string $attributeName
     * @throws \ReflectionException
     * @return PropertyAttribute|null
	 */
	public function getPropertyAttribute(string $propertyName, string $attributeName): PropertyAttribute|null {
		return $this->loadAttributeFromReflector(self::TYPE_PROPERTY, $attributeName,
				$this->class->getProperty($propertyName));
	}
	/**
	 * @param string $name
	 * @return boolean
	 */
	public function containsPropertyAttributeName(string $name): bool {
		return 0 !== count($this->loadAttributes(self::TYPE_PROPERTY, $name));
	}

    /**
     * @return ClassConstantAttribute[]
     */
    public function getClassConstantAttributes(): array {
        if (!$this->isLoaded(self::TYPE_CONSTANT)) {
            $this->loadType(self::TYPE_CONSTANT);
        }

        return $this->unGroup($this->attributes[self::TYPE_CONSTANT]);
    }

    /**
     * @param string $attributeName
     * @return ClassConstantAttribute[]
     */
    public function getClassConstantAttributesByName(string $attributeName): array {
        return $this->loadAttributes(self::TYPE_CONSTANT, $attributeName);
    }

    /**
     * @param string $constantName
     * @param string $attributeName
     * @return boolean
     */
    public function hasClassConstantAttribute(string $constantName, string $attributeName): bool {
        return null !== $this->getClassConstantAttribute($constantName, $attributeName);
    }

    /**
     * @param string $constantName
     * @param string $attributeName
     * @return ClassConstantAttribute|null
     */
    public function getClassConstantAttribute(string $constantName, string $attributeName): ClassConstantAttribute|null {
        return $this->loadAttributeFromReflector(self::TYPE_CONSTANT, $attributeName,
            $this->class->getReflectionConstant($constantName));
    }
    /**
     * @param string $name
     * @return boolean
     */
    public function containsClassConstantAttributeName(string $name): bool {
        return 0 !== count($this->loadAttributes(self::TYPE_CONSTANT, $name));
    }

	/**
	 * @return MethodAttribute[]
	 */
	public function getMethodAttributes(): array {
		if (!$this->isLoaded(self::TYPE_METHOD)) {
			$this->loadType(self::TYPE_METHOD);
		}

		return $this->unGroup($this->attributes[self::TYPE_METHOD]);
	}

	/**
	 * @param string $name
     * @return MethodAttribute[]
	 */
	public function getMethodAttributesByName(string $name): array {
		return $this->loadAttributes(self::TYPE_METHOD, $name);
	}

	/**
	 * @param string $methodName
	 * @param string $attributeName
     * @throws \ReflectionException
	 * @return boolean
	 */
	public function hasMethodAttribute(string $methodName, string $attributeName): bool {
		return null !== $this->getMethodAttribute($methodName, $attributeName);
	}

	/**
	 * @param string $methodName
	 * @param string $attributeName
     * @throws \ReflectionException
     * @return MethodAttribute|null
	 */
	public function getMethodAttribute(string $methodName, string $attributeName): MethodAttribute|null {
		return $this->loadAttributeFromReflector(self::TYPE_METHOD, $attributeName, $this->class->getMethod($methodName));
	}

	/**
	 * @param string $attributeName
	 * @return boolean
	 */
	public function containsMethodAttributeName(string $attributeName): bool {
		return 0 !== count($this->loadAttributes(self::TYPE_METHOD, $attributeName));
	}

    /**
     * @param string $type
     * @param string|null $attributeName
     * @return array
     */
	private function retrieveAttributes(string $type, string $attributeName = null): array {
		if (!isset($this->attributes[$type])) {
			return array();
		}

		if ($attributeName === null) {
			return $this->attributes[$type];
		}

		if (!isset($this->attributes[$type][$attributeName])) {
			return array();
		}

		return $this->attributes[$type][$attributeName];
	}

	/**
	 * @param $type
	 * @param $attributeName
	 * @param $reflectorName
	 * @return ClassAttribute|ClassConstantAttribute|PropertyAttribute|MethodAttribute|null
	 */
	private function retrieveAttribute($type, $attributeName, $reflectorName): ClassAttribute|ClassConstantAttribute|PropertyAttribute|MethodAttribute|null {
		if (!isset($this->attributes[$type][$attributeName][$reflectorName])) {
			return null;
		}

		return $this->attributes[$type][$attributeName][$reflectorName];
	}

    /**
     * @param string $type
     * @param string $attributeName
     * @return array
     */
	private function loadAttributes(string $type, string $attributeName): array {
        if ($this->isLoaded($type, $attributeName)) {
			return $this->retrieveAttributes($type, $attributeName);
		}

		if (!isset($this->attributes[$type][$attributeName])) {
			$this->attributes[$type][$attributeName] = array();
		}

		$reflectors = $this->getReflectorsByType($type);
		foreach ($reflectors as $reflector) {
            $reflectorName = $reflector->getName();
			foreach ($reflector->getAttributes($attributeName) as $attribute) {
				$this->attributes[$type][$attributeName][$reflectorName]
                        = $this->createAttribute($type, $attribute, $reflector);
			}
		}

		$this->loadLegacyAttributes($type, $attributeName);
		$this->setLoaded($type, $attributeName);

		return $this->attributes[$type][$attributeName];
	}

	private function loadType(string $type): array {
        if ($this->isLoaded($type)) {
            return $this->retrieveAttributes($type);
        }

        $reflectors = $this->getReflectorsByType($type);

		foreach ($reflectors as $reflector) {
			$reflectorName = $reflector->getName();
			foreach ($reflector->getAttributes() as $attribute) {
				$attributeName = $attribute->getName();
				if (!isset($this->attributes[$type][$attributeName])) {
					$this->attributes[$type][$attributeName] = array();
				}
				$this->attributes[$type][$attributeName][$reflectorName] =
                        $this->createAttribute($type, $attribute, $reflector);
			}
		}

		$this->loadLegacyType($type);
		$this->setLoaded($type);

        return $this->attributes[$type];
	}

    /**
     * @param string $type
     * @return \Reflector[]
     */
	private function getReflectorsByType(string $type) {
		$reflectors = [];

		if ($type === self::TYPE_CLASS) {
			$reflectors = [$this->class];
		}

		if ($type === self::TYPE_PROPERTY) {
			$reflectors = $this->class->getProperties();
		}

		if ($type === self::TYPE_METHOD) {
			$reflectors = $this->class->getMethods();
		}

		if ($type === self::TYPE_CONSTANT) {
			$reflectors = $this->class->getReflectionConstants();
		}

		return $reflectors;
	}

	private function loadLegacyType($type) {
		if ($type === self::TYPE_CLASS) {
			$this->attributes[$type] = array_merge($this->attributes[$type], $this->legacyConverter->getClassAttributes());
		} elseif ($type === self::TYPE_PROPERTY) {
			$this->attributes[$type] = array_merge($this->attributes[$type], $this->legacyConverter->getPropertyAttributes());
		} elseif ($type === self::TYPE_METHOD) {
			$this->attributes[$type] = array_merge($this->attributes[$type], $this->legacyConverter->getMethodAttributes());
		}
		// constants are not supported for legacy annos
	}

	private function loadLegacyAttributes(string $type, string $attributeName) {
		$loadedLegacyAttrs = [];
		if ($type === self::TYPE_CLASS) {
			$loadedLegacyAttrs = $this->legacyConverter->getClassAttributesByName($attributeName);
		} elseif ($type === self::TYPE_PROPERTY) {
			$loadedLegacyAttrs = $this->legacyConverter->getPropertyAttributesByName($attributeName);
		} elseif ($type === self::TYPE_METHOD) {
			$loadedLegacyAttrs = $this->legacyConverter->getMethodAttributesByName($attributeName);
		}

		if (!isset($this->attributes[$type][$attributeName])) {
			$this->attributes[$type][$attributeName] = $loadedLegacyAttrs;
			return;
		}

		$this->attributes[$type][$attributeName] = array_merge($this->attributes[$type][$attributeName], $loadedLegacyAttrs);
	}

	private function loadLegacyAttribute(string $type, string $attributeName, string $reflectorName): Attribute|null {
        $foundAttribute = null;
        if ($type === self::TYPE_CLASS) {
			$foundAttribute = $this->legacyConverter->getClassAttribute($attributeName);
		}

		if ($type === self::TYPE_METHOD) {
			$foundAttribute = $this->legacyConverter->getMethodAttribute($reflectorName, $attributeName);
		}

		if ($type === self::TYPE_PROPERTY) {
			$foundAttribute = $this->legacyConverter->getPropertyAttribute($reflectorName, $attributeName);
		}

        if ($foundAttribute !== null) {
            $this->attributes[$type][$attributeName][$reflectorName] = $foundAttribute;
        }

        return $foundAttribute;
	}

	/**
	 * @param string $type
	 * @param string $attributeName
	 * @param \Reflector $reflector
	 * @return Attribute|null
	 */
	private function loadAttributeFromReflector(string $type, string $attributeName, \Reflector $reflector): Attribute|null {
		$reflectorName = $reflector->getName();
		if ($this->isLoaded($type, $attributeName, $reflectorName)) {
			return $this->retrieveAttribute($type, $attributeName, $reflectorName);
		}

		if (!isset($this->attributes[$type][$attributeName])) {
			$this->attributes[$type][$attributeName] = array();
		}

		foreach ($reflector->getAttributes($attributeName) as $attribute) {
			$this->attributes[$type][$attributeName][$reflectorName] = $this->createAttribute($type, $attribute, $reflector);
		}


		$this->loadLegacyAttribute($type, $attributeName, $reflectorName);
		$this->setLoaded($type, $attributeName, $reflectorName);

		return $this->retrieveAttribute($type, $attributeName, $reflectorName);
	}

    /**
     * @param string $type
     * @param string|null $attributeName
     * @param string|null $reflectorName
     * @return bool
     */
	private function isLoaded(string $type, string $attributeName = null, string $reflectorName = null) {
		return isset($this->loadedKeys[$this->loadedKey($type)])
                || isset($this->loadedKeys[$this->loadedKey($type, $attributeName)])
                || isset($this->loadedKeys[$this->loadedKey($type, $attributeName, $reflectorName)]);
	}

    /**
     * @param string $type
     * @param string|null $attributeName
     * @param string|null $reflectorName
     */
	private function setLoaded(string $type, string $attributeName = null, string $reflectorName = null) {
		if ($this->isLoaded($type, $reflectorName, $attributeName)) {
			return;
		}

		$this->loadedKeys[$this->loadedKey($type, $attributeName, $reflectorName)] = true;
	}

    /**
     * @param string $type
     * @param \ReflectionAttribute $attribute
     * @param \Reflector $reflector
     * @return ClassAttribute|ClassConstantAttribute|MethodAttribute|PropertyAttribute
     */
	private function createAttribute(string $type, \ReflectionAttribute $attribute, \Reflector $reflector) {
		if ($type === self::TYPE_CLASS) {
			ArgUtils::assertTrue($reflector instanceof ReflectionClass);
			return ClassAttribute::fromAttribute($attribute, $reflector);
		}

		if ($type === self::TYPE_PROPERTY) {
			ArgUtils::assertTrue($reflector instanceof \ReflectionProperty);
			return PropertyAttribute::fromAttribute($attribute, $reflector);
		}

		if ($type === self::TYPE_METHOD) {
			ArgUtils::assertTrue($reflector instanceof \ReflectionMethod);
			return MethodAttribute::fromAttribute($attribute, $reflector);
		}

        if ($type === self::TYPE_CONSTANT) {
            ArgUtils::assertTrue($reflector instanceof \ReflectionClassConstant);
            return ClassConstantAttribute::fromAttribute($attribute, $reflector);
        }

        throw new UnsupportedOperationException($type . ' not supported by AttributeSet::loadLegacyAttribute()');
	}

    /**
     * @param $type
     * @param string|null $attributeName
     * @param string|null $reflectorName
     * @return string
     */
	private function loadedKey(string $type, string $attributeName = null, string $reflectorName = null): string {
		return $type . '-' . $attributeName . '-' . $reflectorName;
	}

    /**
     * @param array $grouped
     * @return array
     */
	private function unGroup(array $grouped): array {
		$attributes = array();
		foreach ($grouped as $groupedAttributes) {
			foreach ($groupedAttributes as $attribute) {
				$attributes[] = $attribute;
			}
		}

		return $attributes;
	}
}